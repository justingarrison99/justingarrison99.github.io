---
layout: post
title: "HW2: Reflections on software engineering practices""
---

  Software inherently holds an abstract nature. Software development serves as a bridge between the physical conceptual world and the abstract world of limitless potential and consequence. At their core these three articles, No Silver Bullet, Kode Vicious, and Google Code Repo, examine this bridge between concept and abstraction in regard to software development, albeit in their own way respectively. The authors do this in order to draw attention to the various challenges that have plagued Software development and then offer practical solutions to these hinderances in the industry. In this blog post I will take a closer look into the challenges each author highlights as well as the solutions they bring forth in order to show the commonalities between the three articles.
	
  Fredrick Brooks Jr frames his article, No Silver Bullet, in the context of the supernatural. He uses the analogy of a werewolf to introduce that core idea of abstraction within Software. Like a werewolf, software can “transform unexpectedly from the familiar into horrors” (Brooks Jr, No Silver Bullet). It’s the abstract nature of software that can be so horrifying as described by Brooks Jr, because while we as software engineers may write beautiful code that works as needed, if the concepts behind the implementation are flawed then the horrific side of our code/repo/project will reveal itself. Brooks Jr describes many inherent and non-inherent challenges of software development, he denotes as essence and accidents, though one that stood out in particular is Invisibility.  Invisibility is an essence of software. Software inherently is difficult to visualize and thus is also difficult to plan, design, and build across a team. In the same way a construction crew refers to the same set of blueprints in order to keep everything efficient and cost-effective. 
  
  Unfortunately, unlike the mythical werewolf which can only be killed by the foretold “Silver Bullet”, there are no silver bullets for the challenges that software engineers encounter and will encounter in their industry. In other words, there is no one-size-fits-all solution. Brooks Jr instead offers the same solution that the budding world of modern medicine and disease-control undertook. Brooks says, “The first step toward the management of disease was replacement of demon theories and humours theories by the germ theory”. In other words, dispel false assumption, come to peace with the fact there is no easy way out(magic silver bullet), and then embrace the stepwise progression towards control over the “scary side” of software. 
  
  George V. Neville-Neil, in his article Kode Vicious, gives a more practical view to the challenges faced in Software Development compared to Brooks Jr’s. Instead of embracing the supernatural, Neville-Neil focuses on the Scientific nature of Software development. This article is written in a Q and A style format where readers have written in questions/concerns to Neville-Neil to which he responds with his own take on the matter. A reader writes in and comments on his own tendency to cherry-pick changes in his repo branch and almost exasperatingly asks, “When do I just give up and merge?” (Kode Vicious). Neville-Neil responds with practically, I can’t tell you when and what to do, but he does offer some solace in the fact that cherry-picking is a common challenge faced across the industry. He says, “you know – deep down, somewhere in that palce that makes you an engineer -- what started out as a quick bit of cherry-picking has turned into a horrific slog through the mud” (Kode Vicious). This comical take cherry-picking also highlights the broad idea of abstraction within software. There are an infinite number of things that you CAN do with your project/software. The environment that software is built in allows for a limitless number of possibilities and conversely comes with many consequences. That’s why Neville-Neil relies so heavily on the scientific method. His solution to the challenges we face as software engineers, is the same as any other scientists’ experiment. Formulate hypotheses, test those hypotheses, and form conclusions from those tests to put it simply. 
  
  In the article, Google Code Repo, Rachel Potvil and Josh Levenberg examine a real-world example of software design by examining Google’s massive single code repository and the pros and cons of the practice. In the article it details how Google utilizes just one code repository across its billions of files of code and across its many different locations. Developers working on anything Google operate on a “Trunk-based development” or in other words… there’s one single stream of commits and changes to the repository. In the context of the Kode Vicious article, this eliminates the problem of out-of-control branches and problematic merges as a consequence. Though this design benefit doesn’t mean it won’t come with its own inherent problems. The main drawback that the authors define is the huge complexity of the codebase. Again, as Brooks Jr wrote in his No Silver Bullet article, there are no fix-all design solutions. 
  
  After examining the three articles mentioned, it’s abundantly clear that a strong commonality regarding the concerns of problematic software design/development lie deeply rooted in the fact software inherently is entirely abstract, not bound by many constraints other than time and hardware, limitless in its nature. It’s often easy to lose focus on the big picture because of this, which is why the authors diligently reinforced the importance of thoughtful and explicit project management and design. In addition to encouraging the embrace of an ethical code of conduct, not to impose penalty and consequence, but to enrich our software design practices and in turn enrich our world.
